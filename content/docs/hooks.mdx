---
title: Hooks
description: Lifecycle callbacks for observability and permission control
---

Hooks let you run custom code at key points in the agent lifecycle. Use them for logging, metrics, auditing, or permission control.

## Available Hooks

| Hook | When it fires |
| --- | --- |
| `beforeRun` | Before the first model call |
| `afterRun` | After the final result is produced |
| `beforeToolCall` | Before a tool's `execute` function runs |
| `afterToolCall` | After a tool's `execute` function returns |
| `beforeHandoff` | Before switching to a handoff agent |

## Usage

```ts title="hooks.ts"
import { Agent } from "stratus/core";

const agent = new Agent({
  name: "assistant",
  model,
  hooks: {
    beforeRun: async ({ agent, input, context }) => {
      console.log(`Starting ${agent.name} with: ${input}`);
    },
    afterRun: async ({ agent, result, context }) => {
      console.log(`${agent.name} finished: ${result.output}`);
    },
    beforeToolCall: async ({ agent, toolCall, context }) => {
      console.log(`Calling tool: ${toolCall.function.name}`);
    },
    afterToolCall: async ({ agent, toolCall, result, context }) => {
      console.log(`Tool ${toolCall.function.name} returned: ${result}`);
    },
    beforeHandoff: async ({ fromAgent, toAgent, context }) => {
      console.log(`Handoff: ${fromAgent.name} â†’ ${toAgent.name}`);
    },
  },
});
```

## Permission Control

`beforeToolCall` and `beforeHandoff` can return a decision object to **allow**, **deny**, or **modify** the action.

<Callout type="info">
Returning `void` (or not returning anything) is treated as "allow", so existing hooks are fully backward compatible.
</Callout>

### Tool Call Decisions

`beforeToolCall` can return a `ToolCallDecision`:

```ts
type ToolCallDecision =
  | { decision: "allow" }
  | { decision: "deny"; reason?: string }
  | { decision: "modify"; modifiedParams: Record<string, unknown> };
```

<Tabs items={["Deny", "Modify", "Allow"]}>
<Tab value="Deny">

When denied, the tool's `execute` function is skipped. The `reason` is returned to the model as the tool message, and `afterToolCall` does **not** fire.

```ts title="deny-tool.ts"
hooks: {
  beforeToolCall: ({ toolCall, context }) => {
    if (toolCall.function.name === "delete_user" && !context.isAdmin) {
      return { decision: "deny", reason: "Admin access required" }; // [!code highlight]
    }
  },
}
```

<Callout type="warn">
If no `reason` is provided, a default message like `Tool call "delete_user" was denied` is used.
</Callout>

</Tab>
<Tab value="Modify">

When modified, the `modifiedParams` are passed to the tool instead of the original parsed arguments. `afterToolCall` still fires.

```ts title="modify-tool.ts"
hooks: {
  beforeToolCall: ({ toolCall }) => {
    if (toolCall.function.name === "search") {
      return {
        decision: "modify", // [!code highlight]
        modifiedParams: { query: "safe version of the query" }, // [!code highlight]
      };
    }
  },
}
```

</Tab>
<Tab value="Allow">

Explicitly allow (same as returning `void`):

```ts
hooks: {
  beforeToolCall: () => {
    return { decision: "allow" };
  },
}
```

</Tab>
</Tabs>

### Handoff Decisions

`beforeHandoff` can return a `HandoffDecision`:

```ts
type HandoffDecision =
  | { decision: "allow" }
  | { decision: "deny"; reason?: string };
```

When denied, the agent switch is blocked - `result.lastAgent` remains the current agent. The denial `reason` is returned as the tool message.

```ts title="deny-handoff.ts"
hooks: {
  beforeHandoff: ({ toAgent, context }) => {
    if (toAgent.name === "admin_agent" && !context.isAdmin) {
      return { decision: "deny", reason: "Admin agent access denied" }; // [!code highlight]
    }
  },
}
```

## Hook Signatures

```ts title="types.ts"
interface AgentHooks<TContext> {
  beforeRun?: (params: {
    agent: Agent<TContext, any>;
    input: string;
    context: TContext;
  }) => void | Promise<void>;

  afterRun?: (params: {
    agent: Agent<TContext, any>;
    result: RunResult<any>;
    context: TContext;
  }) => void | Promise<void>;

  beforeToolCall?: (params: {
    agent: Agent<TContext, any>;
    toolCall: ToolCall;
    context: TContext;
  }) => void | ToolCallDecision | Promise<void | ToolCallDecision>;

  afterToolCall?: (params: {
    agent: Agent<TContext, any>;
    toolCall: ToolCall;
    result: string;
    context: TContext;
  }) => void | Promise<void>;

  beforeHandoff?: (params: {
    fromAgent: Agent<TContext, any>;
    toAgent: Agent<TContext, any>;
    context: TContext;
  }) => void | HandoffDecision | Promise<void | HandoffDecision>;
}
```

## Hooks in Sessions

```ts title="session-hooks.ts"
const session = createSession({
  model,
  hooks: {
    beforeRun: async ({ input }) => {
      await logToAnalytics("user_message", input);
    },
    afterRun: async ({ result }) => {
      await logToAnalytics("agent_response", result.output);
    },
  },
});
```

## Execution Details

<Accordions>
<Accordion title="Which agent do hooks fire on?">
- `beforeRun` and `afterRun` fire on the **entry agent** (the agent passed to `run()` or created by the session)
- `beforeToolCall` and `afterToolCall` fire on the **current agent** (which may change after handoffs)
- `beforeHandoff` fires on the agent performing the handoff (the "from" agent)
</Accordion>
<Accordion title="What happens when a tool call is denied?">
- The tool's `execute` function is **skipped**
- The denial reason is returned to the model as a tool message
- `afterToolCall` does **not** fire
- The model sees the denial and can respond accordingly
</Accordion>
<Accordion title="What happens when a tool call is modified?">
- The `modifiedParams` are passed to the tool's `execute` instead of the original params
- `afterToolCall` **does** fire with the result
</Accordion>
<Accordion title="What happens when a handoff is denied?">
- The agent switch is blocked - `currentAgent` stays the same
- The denial reason replaces the "Transferred to X" tool message
- The model loop continues with the original agent
</Accordion>
</Accordions>
