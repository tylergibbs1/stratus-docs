---
title: Introduction
description: A TypeScript agent SDK for Azure OpenAI
---

Stratus is a TypeScript SDK for building AI agents on Azure OpenAI.

You get agents, tools, multi-turn sessions, streaming, handoffs, guardrails, and tracing. One `run()` call handles the entire tool loop. The types are strict. The API is small.

## Why this exists

Azure's v1 API lets you use the standard `OpenAI()` client, point it at your endpoint, and things mostly work. But "mostly" breaks down fast in production.

The OpenAI SDK gives you `chat.completions.create()`. Everything else is on you:

- **Tool calling is a manual loop.** You call the model, check for tool calls, execute them, append the results, call the model again. Stratus does all of that in one [`run()`](/guides/agentic-tool-use) call with parallel execution and error recovery.
- **No agent abstraction.** You're passing around message arrays. Stratus gives you [agents](/agents) — instructions, tools, guardrails, and handoffs in a single config object.
- **Streaming is bare.** You get raw SSE chunks. Stratus gives you typed [stream events](/streaming) — `content_delta`, `tool_call_start`, `tool_call_done` — with a `RunResult` at the end.
- **Content filter errors are buried.** Azure nests them inside `inner_error.content_filter_results`. Stratus throws a typed [`ContentFilterError`](/errors).
- **Multi-agent orchestration doesn't exist.** [Handoffs](/handoffs), [subagents](/subagents), [guardrails](/guardrails), and [hooks](/hooks) are first-class in Stratus.
- **Both APIs, one interface.** [Chat Completions and Responses API](/azure) through the same `Model` interface. Swap with one line.

## Features

<Cards>
  <Card title="Agents" href="/agents">
    Define agents with instructions, tools, and model settings
  </Card>
  <Card title="Sessions" href="/sessions">
    Multi-turn conversations with save/resume/fork
  </Card>
  <Card title="Tools" href="/tools">
    Type-safe tool definitions with Zod schema validation
  </Card>
  <Card title="Subagents" href="/subagents">
    Delegate work to child agents as tool calls
  </Card>
  <Card title="Streaming" href="/streaming">
    Real-time streaming with abort signal cancellation
  </Card>
  <Card title="Structured Output" href="/structured-output">
    Parse model output into typed objects via Zod
  </Card>
  <Card title="Handoffs" href="/handoffs">
    Route conversations between specialized agents
  </Card>
  <Card title="Hooks" href="/hooks">
    Lifecycle callbacks with permission control (allow/deny/modify)
  </Card>
  <Card title="Guardrails" href="/guardrails">
    Input and output validation with tripwire support
  </Card>
  <Card title="Tracing" href="/tracing">
    Built-in span-based tracing via AsyncLocalStorage
  </Card>
  <Card title="Usage & Cost Tracking" href="/usage-tracking">
    Built-in cost estimation, budget limits, and reasoning token tracking
  </Card>
</Cards>

## Quick Example

```ts title="weather-agent.ts"
import { AzureResponsesModel } from "stratus";
import { createSession, tool } from "stratus/core";
import { z } from "zod";

const model = new AzureResponsesModel({
  endpoint: process.env.AZURE_ENDPOINT!,
  apiKey: process.env.AZURE_API_KEY!,
  deployment: "gpt-5.2",
});

const getWeather = tool({
  name: "get_weather",
  description: "Get current weather for a city",
  parameters: z.object({ city: z.string() }),
  execute: async (_ctx, { city }) => `72°F and sunny in ${city}`,
});

await using session = createSession({
  model,
  instructions: "You are a weather assistant.",
  tools: [getWeather],
});

session.send("What's the weather in NYC?");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}

// Multi-turn: context persists automatically
session.send("What about London?");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}
```

## Architecture

Stratus is organized into two layers:

| Package | Description |
| --- | --- |
| `stratus/core` | Provider-agnostic: Agent, Session, run loop, tools, handoffs, guardrails, hooks, tracing |
| `stratus` | Re-exports core + Azure OpenAI implementation |

The core layer defines the `Model` interface. Azure is the built-in implementation, but you can plug in any provider by implementing `Model`.

## Guides

End-to-end examples showing how to combine features into real agents:

<Cards>
  <Card title="Agentic Tool Use" href="/guides/agentic-tool-use">
    Tool loops, parallel calls, context, streaming, and control
  </Card>
  <Card title="Real-Time Streaming" href="/guides/real-time-streaming">
    Stream to CLI, SSE endpoints, and multi-turn sessions
  </Card>
  <Card title="Customer Support Agent" href="/guides/customer-support-agent">
    Multi-agent triage with handoffs, hooks, and guardrails
  </Card>
  <Card title="Research Agent" href="/guides/research-agent">
    Orchestrate subagents for web research and data analysis
  </Card>
  <Card title="Data Extraction Pipeline" href="/guides/data-extraction">
    Structured output with validation guardrails and batch processing
  </Card>
</Cards>

## Project Structure

<Files>
  <Folder name="src" defaultOpen>
    <Folder name="core" defaultOpen>
      <File name="agent.ts" />
      <File name="run.ts" />
      <File name="session.ts" />
      <File name="tool.ts" />
      <File name="subagent.ts" />
      <File name="handoff.ts" />
      <File name="hooks.ts" />
      <File name="guardrails.ts" />
      <File name="tracing.ts" />
      <File name="cost.ts" />
      <File name="types.ts" />
      <File name="model.ts" />
      <File name="errors.ts" />
    </Folder>
    <Folder name="azure">
      <File name="chat-completions-model.ts" />
      <File name="responses-model.ts" />
      <File name="sse-parser.ts" />
    </Folder>
  </Folder>
</Files>
