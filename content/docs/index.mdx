---
title: Introduction
description: A TypeScript agent SDK for Azure OpenAI
---

Stratus is a TypeScript SDK for building AI agents powered by Azure OpenAI. It provides a clean, composable API for multi-turn conversations, tool use, multi-agent handoffs, streaming, guardrails, and tracing.

## Why this exists

Azure OpenAI's developer experience got a lot better in August 2025 when Microsoft shipped the v1 API. You can now use the standard `OpenAI()` client from the `openai` npm package, point it at your Azure endpoint, and things mostly just work.

**So why build another SDK?**

Because "mostly just work" isn't good enough for production. The v1 API solved the worst pain points — no more `api-version` query strings, no more `AzureOpenAI()` client, standard method names. But there's a layer of functionality that the vanilla OpenAI SDK doesn't touch, and the gaps that remain are exactly the ones that burn you at scale:

- **Tool calling requires a manual loop.** Zod schema to tool definition to model call to tool execution to response... this should be a single `run()` call with full type inference, not 80 lines of boilerplate. Stratus handles the entire [tool loop automatically](/docs/guides/agentic-tool-use) — parallel calls, multi-round execution, argument validation, error recovery.
- **There's no agent abstraction.** The OpenAI SDK gives you `chat.completions.create()`. Building agents with instructions, tools, guardrails, handoffs, and session management on top of that is entirely on you. Stratus provides [composable agents](/docs/agents) with a clean config object.
- **Streaming helpers are basic.** The OpenAI SDK gives you async iteration over raw chunks. Stratus gives you typed [stream events](/docs/streaming) — `content_delta`, `tool_call_start`, `tool_call_done` — with content accumulation and a final `RunResult`.
- **Content filter errors are opaque.** Azure wraps policy violations in `inner_error.content_filter_results` but the OpenAI client throws a generic error. Stratus throws a typed [`ContentFilterError`](/docs/errors) you can catch and handle.
- **Multi-agent orchestration doesn't exist.** [Handoffs](/docs/handoffs) between specialized agents, [subagent delegation](/docs/subagents), [guardrails](/docs/guardrails), [hooks](/docs/hooks) for permission control — none of this exists in the vanilla SDK. Stratus makes these first-class.
- **The Responses API is the future, but adoption is low.** Microsoft recommends the [Responses API](https://learn.microsoft.com/en-us/azure/ai-services/openai/how-to/responses) for new development. Stratus supports both the [Chat Completions and Responses API](/docs/azure) through the same `Model` interface — swap with one line.

The goal: feel like Anthropic's TypeScript SDK — clean, typed, zero-config for the common case — while properly wrapping Azure's unique capabilities.

## Features

<Cards>
  <Card title="Agents" href="/docs/agents">
    Define agents with instructions, tools, and model settings
  </Card>
  <Card title="Sessions" href="/docs/sessions">
    Multi-turn conversations with save/resume/fork
  </Card>
  <Card title="Tools" href="/docs/tools">
    Type-safe tool definitions with Zod schema validation
  </Card>
  <Card title="Subagents" href="/docs/subagents">
    Delegate work to child agents as tool calls
  </Card>
  <Card title="Streaming" href="/docs/streaming">
    Real-time streaming with abort signal cancellation
  </Card>
  <Card title="Structured Output" href="/docs/structured-output">
    Parse model output into typed objects via Zod
  </Card>
  <Card title="Handoffs" href="/docs/handoffs">
    Route conversations between specialized agents
  </Card>
  <Card title="Hooks" href="/docs/hooks">
    Lifecycle callbacks with permission control (allow/deny/modify)
  </Card>
  <Card title="Guardrails" href="/docs/guardrails">
    Input and output validation with tripwire support
  </Card>
  <Card title="Tracing" href="/docs/tracing">
    Built-in span-based tracing via AsyncLocalStorage
  </Card>
</Cards>

## Quick Example

```ts title="weather-agent.ts"
import { AzureChatCompletionsModel } from "stratus";
import { createSession, tool } from "stratus/core";
import { z } from "zod";

const model = new AzureChatCompletionsModel({
  endpoint: process.env.AZURE_ENDPOINT!,
  apiKey: process.env.AZURE_API_KEY!,
  deployment: "gpt-5.2",
});

const getWeather = tool({
  name: "get_weather",
  description: "Get current weather for a city",
  parameters: z.object({ city: z.string() }),
  execute: async (_ctx, { city }) => `72°F and sunny in ${city}`,
});

await using session = createSession({
  model,
  instructions: "You are a weather assistant.",
  tools: [getWeather],
});

session.send("What's the weather in NYC?");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}

// Multi-turn: context persists automatically
session.send("What about London?");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}
```

## Architecture

Stratus is organized into two layers:

| Package | Description |
| --- | --- |
| `stratus/core` | Provider-agnostic: Agent, Session, run loop, tools, handoffs, guardrails, hooks, tracing |
| `stratus` | Re-exports core + Azure OpenAI implementation |

The core layer defines the `Model` interface. Azure is the built-in implementation, but you can plug in any provider by implementing `Model`.

## Guides

End-to-end examples showing how to combine features into real agents:

<Cards>
  <Card title="Agentic Tool Use" href="/docs/guides/agentic-tool-use">
    Tool loops, parallel calls, context, streaming, and control
  </Card>
  <Card title="Real-Time Streaming" href="/docs/guides/real-time-streaming">
    Stream to CLI, SSE endpoints, and multi-turn sessions
  </Card>
  <Card title="Customer Support Agent" href="/docs/guides/customer-support-agent">
    Multi-agent triage with handoffs, hooks, and guardrails
  </Card>
  <Card title="Research Agent" href="/docs/guides/research-agent">
    Orchestrate subagents for web research and data analysis
  </Card>
  <Card title="Data Extraction Pipeline" href="/docs/guides/data-extraction">
    Structured output with validation guardrails and batch processing
  </Card>
</Cards>

<Files>
  <Folder name="src" defaultOpen>
    <Folder name="core" defaultOpen>
      <File name="agent.ts" />
      <File name="run.ts" />
      <File name="session.ts" />
      <File name="tool.ts" />
      <File name="subagent.ts" />
      <File name="handoff.ts" />
      <File name="hooks.ts" />
      <File name="guardrails.ts" />
      <File name="tracing.ts" />
      <File name="types.ts" />
      <File name="model.ts" />
      <File name="errors.ts" />
    </Folder>
    <Folder name="azure">
      <File name="chat-completions-model.ts" />
      <File name="responses-model.ts" />
      <File name="sse-parser.ts" />
    </Folder>
  </Folder>
</Files>
