---
title: Handoffs
description: Route conversations between specialized agents
---

Handoffs let one agent transfer a conversation to another agent mid-turn. This enables multi-agent architectures like triage â†’ specialist routing.

## Basic Handoff

Pass agents directly to `handoffs`. Stratus auto-generates a tool named `transfer_to_{agent_name}`:

```ts title="handoff.ts"
import { Agent, run } from "stratus-sdk/core";

const mathAgent = new Agent({
  name: "math",
  model,
  instructions: "You are a math expert. Solve math problems.",
});

const triageAgent = new Agent({
  name: "triage",
  model,
  instructions: "Route the user to the right specialist.",
  handoffs: [mathAgent],
});

const result = await run(triageAgent, "What is the integral of x^2?");
console.log(result.lastAgent.name); // "math"
```

## Custom Handoff Configuration

Use the `handoff()` function for more control:

```ts title="custom-handoff.ts"
import { handoff } from "stratus-sdk/core";

const agent = new Agent({
  name: "triage",
  model,
  handoffs: [
    handoff({
      agent: mathAgent,
      toolName: "escalate_to_math", // [!code highlight]
      toolDescription: "Escalate complex math problems to the math specialist",
      onHandoff: async (ctx) => { // [!code highlight]
        console.log("Handing off to math agent");
        await logHandoff(ctx, "math");
      },
    }),
  ],
});
```

### Handoff Config Options

| Property | Type | Description |
| --- | --- | --- |
| `agent` | `Agent` | **Required.** The target agent |
| `toolName` | `string` | Custom tool name (default: `transfer_to_{name}`) |
| `toolDescription` | `string` | Custom description for the model |
| `onHandoff` | `(ctx) => void` | Callback that fires when the handoff executes |

## How Handoffs Work

<Steps>
<Step>

### Registered as tool

The handoff is registered as a tool definition alongside the agent's other tools.

</Step>
<Step>

### Model calls the tool

When the model decides to hand off, it calls the handoff tool.

</Step>
<Step>

### Callback fires

Stratus executes `onHandoff` (if provided), then replaces the current agent with the target.

</Step>
<Step>

### System prompt swaps

The system prompt is replaced with the new agent's instructions. The model loop continues.

</Step>
</Steps>

<Callout type="info">
Handoffs can be blocked by `beforeHandoff` hooks returning `{ decision: "deny" }`. See [Hooks - Permission Control](/hooks#permission-control).
</Callout>

## Handoffs in Sessions

```ts title="session-handoff.ts"
const session = createSession({
  model,
  instructions: "Route users to the right specialist.",
  handoffs: [mathAgent, writingAgent],
});

session.send("Help me write a poem");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}

const result = await session.result;
console.log(result.lastAgent.name); // "writing"
```

<Callout type="warn">
Each `stream()` call starts from the session's configured agent. Handoffs within a turn don't persist to the next turn.
</Callout>

## Multi-Agent Patterns

### Triage Pattern

A triage agent routes to specialists based on the user's request:

```ts title="triage.ts"
const orderAgent = new Agent({
  name: "orders",
  model,
  instructions: "Help with order lookups and status.",
  tools: [lookupOrder],
  handoffDescription: "Transfer for order status and tracking", // [!code highlight]
});

const refundAgent = new Agent({
  name: "refunds",
  model,
  instructions: "Process refund requests.",
  tools: [processRefund],
  handoffDescription: "Transfer for refund processing", // [!code highlight]
});

const triage = new Agent({
  name: "triage",
  model,
  instructions: "You are a customer support triage agent.",
  handoffs: [orderAgent, refundAgent],
});
```

<Callout type="info" title="Handoffs vs Subagents">
Handoffs **transfer control** - the child takes over. Subagents **delegate and return** - the parent keeps control. See [Subagents](/subagents) for the delegation pattern.
</Callout>
