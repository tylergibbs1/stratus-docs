---
title: Handoffs
description: Route conversations between specialized agents
---

Handoffs let one agent transfer a conversation to another agent mid-turn. This enables multi-agent architectures like triage â†’ specialist routing.

## Basic Handoff

Pass agents directly to `handoffs`. Stratus auto-generates a tool named `transfer_to_{agent_name}`:

```ts title="handoff.ts"
import { Agent, run } from "stratus-sdk/core";

const mathAgent = new Agent({
  name: "math",
  model,
  instructions: "You are a math expert. Solve math problems.",
});

const triageAgent = new Agent({
  name: "triage",
  model,
  instructions: "Route the user to the right specialist.",
  handoffs: [mathAgent],
});

const result = await run(triageAgent, "What is the integral of x^2?");
console.log(result.lastAgent.name); // "math"
```

## Custom Handoff Configuration

Use the `handoff()` function for more control:

```ts title="custom-handoff.ts"
import { handoff } from "stratus-sdk/core";

const agent = new Agent({
  name: "triage",
  model,
  handoffs: [
    handoff({
      agent: mathAgent,
      toolName: "escalate_to_math", // [!code highlight]
      toolDescription: "Escalate complex math problems to the math specialist",
      onHandoff: async (ctx) => { // [!code highlight]
        console.log("Handing off to math agent");
        await logHandoff(ctx, "math");
      },
    }),
  ],
});
```

### Handoff Config Options

| Property | Type | Description |
| --- | --- | --- |
| `agent` | `Agent` | **Required.** The target agent |
| `toolName` | `string` | Custom tool name (default: `transfer_to_{name}`) |
| `toolDescription` | `string` | Custom description for the model |
| `onHandoff` | `(ctx) => void` | Callback that fires when the handoff executes |
| `inputType` | `z.ZodType` | Zod schema for structured input the model sends with the handoff |
| `inputFilter` | `HandoffInputFilter` | Transform conversation history passed to the target agent |
| `isEnabled` | `boolean \| (ctx) => boolean` | When `false`, the handoff is excluded from the model's tool list |

### Structured Handoff Input

Use `inputType` to let the model send structured data with a handoff. The Zod schema becomes the tool's parameter schema:

```ts title="structured-handoff.ts"
import { handoff } from "stratus-sdk/core";
import { z } from "zod";

const agent = new Agent({
  name: "triage",
  model,
  handoffs: [
    handoff({
      agent: mathAgent,
      inputType: z.object({ // [!code highlight]
        problem: z.string().describe("The math problem to solve"), // [!code highlight]
        difficulty: z.enum(["easy", "medium", "hard"]), // [!code highlight]
      }), // [!code highlight]
    }),
  ],
});
```

### Input Filter

Use `inputFilter` to transform the conversation history before it's passed to the target agent. This is useful for trimming irrelevant messages or redacting sensitive content:

```ts title="input-filter.ts"
handoff({
  agent: specialistAgent,
  inputFilter: ({ history, input }) => { // [!code highlight]
    // Only pass user and assistant messages (drop tool messages)
    return history.filter((m) => m.role === "user" || m.role === "assistant");
  },
});
```

The filter receives a `HandoffInputData` object:

```ts
interface HandoffInputData {
  history: ChatMessage[];  // Full conversation history
  input?: unknown;         // Parsed input (if inputType is set)
}
```

### Conditional Handoffs (isEnabled)

Use `isEnabled` to dynamically include or exclude a handoff based on context:

```ts title="conditional-handoff.ts"
handoff({
  agent: adminAgent,
  isEnabled: (ctx: AppContext) => ctx.isAdmin, // [!code highlight]
});
```

When `false`, the handoff tool is not sent to the model. Same pattern as [conditional tools](/tools#conditional-tools-isenabled).

## How Handoffs Work

<Steps>
<Step>

### Registered as tool

The handoff is registered as a tool definition alongside the agent's other tools.

</Step>
<Step>

### Model calls the tool

When the model decides to hand off, it calls the handoff tool.

</Step>
<Step>

### Callback fires

Stratus executes `onHandoff` (if provided), then replaces the current agent with the target.

</Step>
<Step>

### System prompt swaps

The system prompt is replaced with the new agent's instructions. The model loop continues.

</Step>
</Steps>

<Callout type="info">
Handoffs can be blocked by `beforeHandoff` hooks returning `{ decision: "deny" }`. See [Hooks - Permission Control](/hooks#permission-control).
</Callout>

## Handoffs in Sessions

```ts title="session-handoff.ts"
const session = createSession({
  model,
  instructions: "Route users to the right specialist.",
  handoffs: [mathAgent, writingAgent],
});

session.send("Help me write a poem");
for await (const event of session.stream()) {
  if (event.type === "content_delta") process.stdout.write(event.content);
}

const result = await session.result;
console.log(result.lastAgent.name); // "writing"
```

<Callout type="warn">
Each `stream()` call starts from the session's configured agent. Handoffs within a turn don't persist to the next turn.
</Callout>

## Multi-Agent Patterns

### Triage Pattern

A triage agent routes to specialists based on the user's request:

```ts title="triage.ts"
const orderAgent = new Agent({
  name: "orders",
  model,
  instructions: "Help with order lookups and status.",
  tools: [lookupOrder],
  handoffDescription: "Transfer for order status and tracking", // [!code highlight]
});

const refundAgent = new Agent({
  name: "refunds",
  model,
  instructions: "Process refund requests.",
  tools: [processRefund],
  handoffDescription: "Transfer for refund processing", // [!code highlight]
});

const triage = new Agent({
  name: "triage",
  model,
  instructions: "You are a customer support triage agent.",
  handoffs: [orderAgent, refundAgent],
});
```

<Callout type="info" title="Handoffs vs Subagents">
Handoffs **transfer control** - the child takes over. Subagents **delegate and return** - the parent keeps control. See [Subagents](/subagents) for the delegation pattern.
</Callout>
